# dinic的时间复杂度
最慢应该是O((n^2)*m)，n表点数，m表边数

```c++
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<queue>
using namespace std;
const int maxN=100;//点数
const int maxM=1e6+5;//边数必须是给定边数的两倍，还有反向边 
const int inf=0x3f3f3f3f; 
int s,t,n,cnt;//源点s 汇点t 点的总数n 链式前向星cnt 
int head[maxN],Next[maxM];//每个点最后一条边的编号，指向对应点的前一条边 N大写 
int w[maxM];//每一条边的残量
int v[maxM];//每一条边指向的点 
int depth[maxN];//分层图的深度
int cur[maxN];//记录当前点u循环到哪一条边 
void init(){
	cnt=-1;
	memset(head,-1,sizeof(head));
	memset(Next,-1,sizeof(Next)); 
} 
void set_st(int source,int terminal){
	s=source,t=terminal;
}
void add(int u,int vi,int weight){
	cnt++;
	Next[cnt]=head[u];
	head[u]=cnt;
	v[cnt]=vi;
	w[cnt]=weight;
}
void add_edge(int u,int v,int w){
	add(u,v,w);
	add(v,u,0);//反向边设为0 
}
int dfs(int u,int flow){//u是当前节点，flow是当前流量 
	//达到汇点直接返回 
	if(u==t)return flow;
	for(int& i=cur[u];i!=-1;i=Next[i]){//& i增加的同时改变cur[u]的值，记录当前弧 
		if((depth[v[i]]==depth[u]+1)&&(w[i]!=0)){//如果满足分层图条件并且参量不为0 
			int di=dfs(v[i],min(flow,w[i]));
			if(di>0){//增广成功 
				w[i]-=di;//正向边减 
				w[i^1]+=di;//反向边加 
				return di;//返回流量 
			} 
		}
	}
	return 0;//增广失败，返回0 
}
bool bfs(){
	queue<int> q;
	while(!q.empty())q.pop();
	memset(depth,0,sizeof(depth));
	depth[s]=1;//源点的深度为1
	q.push(s);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i!=-1;i=Next[i]){
			if((depth[v[i]]==0)&&(w[i]>0)){//深度等于0博那个且残量大于0 
				depth[v[i]]=depth[u]+1;
				q.push(v[i]); 
			}
		}
	} 
	if(!depth[t])return 0;//如果汇点的深度为0，则不存在增广路
	return 1; //如果汇点的深度不为0，则存在增广路
}
int Dinic(){
	int ans=0;//记录最大流
	while(bfs()){//存在增广路 
		for(int i=1;i<=n;i++){//当前弧优化 
			cur[i]=head[i];
		}
		while(int d=dfs(s,inf)){
			ans+=d;
		}
	} 
	return ans;
}
int main(){
	//用法：
    //输入点的总数，给n赋值
    //初始化init()
    //建边add_edge()
    //设置源点汇点set_st()
    //ans=Dinic()
}