# 概念

* 在普通游戏规则下，最后一个走步的游戏者胜
* 在 misere 游戏规则下，最后一个走步的游戏者输
* P 状态和 N 状态
  * 刚完成走步的游戏者 (Previous Player) 一定胜利
  * 而对于其他状态，下一个走步的游戏者 (Next Player) 一定胜利
  * P 状态可以认为是必败状态，N 状态可以认为是必胜状态
  * 所有终止状态是 P 状态（在普通游戏规则下试用）
  * 能一步到达 P 状态的状态为 N 状态
  * 每一步都将到达 N 状态的状态为 P 状态
  * 对于每个状态，考察它的后继状态，如果其中有 P 状态，则当前状态为 N 状态，否则，当前状态为 P 状态
* 核心：寻找必败状态（任何人面对必败状态下都是必败，即奇异面前先手必亡）
必败状态特点：
  * 任何必败状态经一次操作后必然变成非必败状态，否则就变成对方面对必败状态，那就不是必败
  * 非必败态一定可以移动到必败态，故对于一局博弈和足够聪明的玩家来说，开局状态和先后次序就已经知道谁胜谁负

# 硬币游戏

* 有 x 枚硬币，Alice 和 Bob 轮流从中取硬币。每次取的个数一定要在给定的 k 个数 a1,a2,……,ak 之中。Alice 先取，取走最后一枚硬币的一方获胜。当双方都采取最优策略时候，谁会获胜？（假设 a1,a2,……,ak 中一定有 1）
  * 时间复杂度 O(MAX_X*k)
  * 代码
  ```c++
    //用于判断P状态和N状态的数组
    //false表示P状态，true表示N状态
    bool win[MAX_X+1];
    void solve(){
        win[0]=false;
        for (j=1;j<=x;j++){
            win[j]=false;
            for (i=0;i<k;i++){
                if (j>=a[i]&&!win[j-a[i]]) win[j]=true;
            }
        } 
        if (win[x]) cout<<Alice<<endl;
        else cout<<Bob<<endl;	
    }
  ```

# 巴什博弈

* 有一堆 n 个物品，两个人轮流从这堆物品中取，规定每次至少取一个，最多取 m 个。最后取光者得胜。
* 巴什博弈的必败态：n % (m+1) == 0 先手必败，否则先手必胜
* 分析：一旦石头个数成为（m+1)的倍数（倘若至少为 p，则将 1 换为 p），先手取多少，后手都可以凑成（m+p)使得剩下的石头个数仍是必败状态，直到取完，先手失败。
  
# 威佐夫博弈

* 有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜
* 威佐夫博弈的必败态：$a=(b-a)*\frac{\sqrt{5}+1}{2},b=a+(b-a)$
* 分析：威佐夫序列对（即博弈必败态） (0,0),(1,2),(3,5),(4,7),(6,10),(8,13),(9,15),(11,18),(ai,bi),ai 为前面未出现过的最小整数，bi=ai+k,k 为自然数 0,1,2,3……
该序列对的规律便可由必败态公式中的**黄金分割比**来写

# 尼姆博弈

* 有 3 堆物品，每堆个数若干，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜
* **尼姆博弈的必败态：各队石子数目的异或和为 0（$x_1 \bigoplus x_2 \bigoplus x_3…… \bigoplus x_n==0$）**
* Bouton 定理：在 Nim 游戏中，状态(x1, x2, x3)为 P 状态当且仅当 x1 xor x2 xor x3==0，其中 xor 为二进值异或操作。将原问题推广到 n 维物品，Bouton 定理同样成立。
* 证明每个 Nim 和不等于 0 的状态总能`有一种`方法转移到 Nim 和等于 0 的状态
* 证明每个 Nim 和等于 0 的状态`一定`转移到 Nim 和不等于 0 的状态 
* Nim 和 ==0->P 状态，Nim 和!=0->N 状态
* misere 规则下的 Nim 博弈

## 拓展变换

（1） **普通类型**：判断胜利者，直接根据异或和判断
（2） **先取完者判输**：统计所有大于 1 的堆的个数 num，再求异或和 jud（改变必败状态:奇数个 1 ）
    
```c++
if(((num==0)&&(jud==0)) || ((num>0)&&(jud!=0)))  先手胜
else 后手胜
```

（3） **限制最多取的个数**：改变石子数量。第 i 堆石子有 m 个，最多取 r 个，做**m=m%(r+1)**,再按普通类型做（异或和）
（4） **先手的人想赢，第一步有多少种选择**：首先求出所有堆异或后的值 sum，再用这个值去对每一个堆进行异或。**对任一堆$x_i,res=sum \bigoplus x_i$**，如果$res < x_i$的话，当前玩家就从$x_i$中取走$（x_i - res）$个，使得剩下的必然导致所有的堆的异或值为 0，也就是必败点（达到奇异局势），这就是一种方案。遍历每一个堆，进行上面的断判就可以得到总的方案数。
  
# 斐波那契博弈

* 有一堆个数为 n 的石子，游戏双方轮流取石子，满足
  * 1)先手不能在第一次把所有的石子取完；
  * 2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。约定取走最后一个石子的人为赢家。
  * 先手胜当且仅当 n 不是 Fibonacci 数。必败态构成 Fibonacci 数列。
  * “Zeckendorf 定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。
  
# SG 函数与 SG 定理

* SG 函数：Sprague-Grundy 函数。首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示不属于这个集合的最小非负整数。例如 mex{0,1,2,4}=3、mex{1,3,5}=0、mex{}=0
* 对于一个给定的有向无环图，定义关于图的每个顶点的 SG 函数 g 如下：g(x)=mex{ g(y) | y 是 x 的后继 }。
* 考察 SG 函数与 NP 状态的关系：SG(pos)==0  <=>  P 状态；SG(pos)!=0  <=>   N 状态
* 求法：对当前节点建个 set，把所有后继节点的 SG 值放入其中，然后从 0 开始往上找，找到第一个不在集合中的自然数。


* SG 定理：组合游戏和（整个游戏）的 SG 函数等于各个游戏 SG 函数的 Nim 和。整个游戏的 SG 函数=0  <=> 必败状态；整个游戏的 SG 函数!=0 <=> 必胜状态
* 初始局面包含每个子游戏的初始局面，而每次每个游戏者可以任意选一个子游戏，进行一次合法走步，而让其他游戏局面保持不变。
* 回过头来看 Nim 游戏的话，我们就能从一个更高的角度看因为对每一堆石子，我们有 SG(x)=x

* 利用 SG 函数和 SG 定理解题
  * 把原游戏分解成多个独立的子游戏，则原游戏的 SG 函数值是它的所有子游戏的 SG 函数值的 Nim 和，即 SG(G)=SG(G1)^SG(G2)^...^SG(Gn)
  * 分别考虑每一个子游戏，计算其 SG 值。
  * 对每一个子游戏求 SG 值时，一般可以选择打表找规律，实在找不到规律再老老实实用定义求 SG 值的方法。一些对时间复杂度要求较高的题，无法通过定义求 SG 值，这时只能选择找规律。

# 总结

* 对于单个的游戏，用 P 状态和 N 状态去判断会更方便一些，但要处理组合游戏的和时，SG 函数和 SG 定理就凸显出优势
* 一些题中只有 1 个元素的堆的个数会是一个分类讨论点
* 在组合游戏中的技巧是对称性的考虑，就是说与对面采用一种完全争锋相对的做法，并且保证无论对面如何出招，自己都有可以采用的应对招数
* 各种类型的博弈问题：分类，寻找不同类型下的**必败状态**
* **对于二元状态来说，可以通过递推：**
  * 凡能转移到一个必败态的状态为必胜态
  * 能转移到的所有状态都是必胜态的状态则为必败态
* 对于普通博弈，常用的是寻找必败态然后递推
* 对于博弈规律，需要应用相应的状态规律，比如求胜利者、求方案数、求胜利路径等等
* 博弈问题可以转成棋盘问题，如下题所示

## 样例

有一个 n*m 的棋盘，棋子初始位置为(1,1),要走到（n,m),两个人轮流走，B 先手 G 后手，棋子的规则有四种：（1）king 国王（只能走周围把八个格子）；（2）rook 车（只能走直线）；（3）knight 马（只能走“日”字）；（4）quuen 皇后（走直线和斜线）规定每一次走必须至少满足向右或向下，即（x,y)下一个点（x',y')需满足 x'>=x,y'>=y

```c++
输出：胜利者
输入：（样例个数;棋子类型,n,m)
4
1 5 5
2 5 5
3 5 5
4 5 5
输出：（胜利者G或B,平手则为D）
G
G
D
B
```

```c++
#pragma warning(disable:4996)
#include <iostream>
#include <cstdio>
#include <string.h>
#include <cmath>
#include<algorithm>
#define LL long long
#define d (sqrt(5)+1)/2　//黄金比例
using namespace std;
int main()
{
	int t, type, n, m;
	cin >> t;
	while (t--)
	{
		scanf("%d%d%d", &type, &n, &m);
		if (m > 1000 || n > 1000 || n < 2 || m < 2)
			continue;
		n--, m--;
		if (type == 1)//王穷举
		{
			if (n % 2 == 0 && m % 2 == 0)
				printf("G\n");
			else
				printf("B\n");
		}
		if (type == 2)//车尼姆博弈
		{
			if (n == m)
			{
				printf("G\n");
			}
			else
				printf("B\n");
		}
		if (type == 3)//马
			//因为只能向右下走所以有两种走法，左１右２，和左２右１；棋盘内有的是可以到达且到达的步数是不变的，分别设走１的k1步,第２种走法的为k2步;
			//可以有方程k1*1+k2*2=m,k1*2+k2*1=n;联立求解，若k1,k2为正整数则能分出胜负；
			//根据奇偶求胜负。但是还有一点要注意，因为谁都不想输所以要输的人尽量走成平局，这种情况需判断k1与k2间之差大于等于２；大于２就是平局，不难推出。
		{
			if ((2 * n - m) / 3 * 3 == 2 * n - m && (2 * m - n) / 3 * 3 == 2 * m - n)
			{
				int k1 = (2 * n - m) / 3;
				int k2 = (2 * m - n) / 3;
				int k = k2 + k1;
				if (abs(k1 - k2) > 1)
				{
					printf("D\n");
					continue;
				}
				else if (k % 2 == 0)//奇偶性判断胜方
				{
					printf("G\n");
				}
				else
					printf("B\n");
			}
			else
				printf("D\n");
		}
		if (type == 4)
		{
			if ((int)(abs(n - m)*((sqrt(5) + 1) / 2)) == min(n, m))//威佐夫博弈
			{
				printf("G\n");
			}
			else
				printf("B\n");
		}
	}
	return 0;
}
```