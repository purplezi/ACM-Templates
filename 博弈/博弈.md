# 概念

* 在普通游戏规则下，最后一个走步的游戏者胜
* 在misere游戏规则下，最后一个走步的游戏者输
* P状态和N状态
  * 刚完成走步的游戏者(Previous Player) 一定胜利
  * 而对于其他状态，下一个走步的游戏者(Next Player) 一定胜利。
  * P状态可以认为是必败状态，N状态可以认为是必胜状态
  * 所有终止状态是P状态（在普通游戏规则下试用）
  * 能一步到达P状态的状态为N状态
  * 每一步都将到达N状态的状态为P状态
  * 对于每个状态，考察它的后继状态，如果其中有P状态，则当前状态为N状态，否则，当前状态为P状态

# 硬币游戏

* 有x枚硬币，Alice和Bob轮流从中取硬币。每次取的个数一定要在给定的k个数a1,a2,……,ak之中。Alice先取，取走最后一枚硬币的一方获胜。当双方都采取最优策略时候，谁会获胜？（假设a1,a2,……,ak中一定有1）
  * 时间复杂度O(MAX_X*k)
  * 代码
  ```c++
    //用于判断P状态和N状态的数组
    //false表示P状态，true表示N状态
    bool win[MAX_X+1];
    void solve(){
        win[0]=false;
        for (j=1;j<=x;j++){
            win[j]=false;
            for (i=0;i<k;i++){
                if (j>=a[i]&&!win[j-a[i]]) win[j]=true;
            }
        } 
        if (win[x]) cout<<Alice<<endl;
        else cout<<Bob<<endl;	
    }
  ```

# 巴什博弈

* 有一堆n个物品，两个人轮流从这堆物品中取，规定每次至少取一个，最多取m个。最后取光者得胜。
* n%(m+1)==0 先手必败，否则先手必胜
  
# 威佐夫博弈

* 有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜
* 先手必败：(0,0),(1,2),(3,5),(4,7),(6,10),(8,13),(9,15),(11,18),(12,20)……
* 先手必败状态记为(ak,bk)的话，k是序号(从0开始),ak是未在前面出现过的最小自然数,而bk=ak+k
* 公式：ak=[k(1+√5)/2]，bk=ak+k(k=0,1,2,…,n,方括号表示向下取整函数)

# 尼姆博弈

* 有3堆物品，每堆个数若干，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜
* Bouton定理：在Nim游戏中，状态(x1, x2, x3)为P状态当且仅当x1 xor x2 xor x3==0，其中xor为二进值异或操作。将原问题推广到n维物品，Bouton定理同样成立。
* 证明每个Nim和不等于0的状态总能`有一种`方法转移到Nim和等于0的状态
* 证明每个Nim和等于0的状态`一定`转移到Nim和不等于0的状态 
* Nim和==0->P状态，Nim和!=0->N状态
* misere规则下的Nim博弈
  
# 斐波那契博弈

* 有一堆个数为n的石子，游戏双方轮流取石子，满足：
1)先手不能在第一次把所有的石子取完；
2)之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。
约定取走最后一个石子的人为赢家。
* 先手胜当且仅当n不是Fibonacci数。必败态构成Fibonacci数列。
* “Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。
  
# SG函数与SG定理

* SG函数：Sprague-Grundy函数。首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示不属于这个集合的最小非负整数。例如mex{0,1,2,4}=3、mex{1,3,5}=0、mex{}=0
* 对于一个给定的有向无环图，定义关于图的每个顶点的SG函数g如下：g(x)=mex{ g(y) | y是x的后继 }。
* 考察SG函数与NP状态的关系：SG(pos)==0  <=>  P 状态；SG(pos)!=0  <=>   N 状态
* 求法：对当前节点建个set，把所有后继节点的SG值放入其中，然后从0开始往上找，找到第一个不在集合中的自然数。


* SG定理：组合游戏和（整个游戏）的SG函数等于各个游戏SG函数的Nim和。整个游戏的SG函数=0  <=> 必败状态；整个游戏的SG函数!=0 <=> 必胜状态
* 初始局面包含每个子游戏的初始局面，而每次每个游戏者可以任意选一个子游戏，进行一次合法走步，而让其他游戏局面保持不变。
* 回过头来看Nim游戏的话，我们就能从一个更高的角度看因为对每一堆石子，我们有SG(x)=x

* 利用SG函数和SG定理解题
  * 把原游戏分解成多个独立的子游戏，则原游戏的SG函数值是它的所有子游戏的SG函数值的Nim和，即SG(G)=SG(G1)^SG(G2)^...^SG(Gn)
  * 分别考虑每一个子游戏，计算其SG值。
  * 对每一个子游戏求SG值时，一般可以选择打表找规律，实在找不到规律再老老实实用定义求SG值的方法。一些对时间复杂度要求较高的题，无法通过定义求SG值，这时只能选择找规律。

# 总结

* 对于单个的游戏，用P状态和N状态去判断会更方便一些，但要处理组合游戏的和时，SG函数和SG定理就凸显出优势
* 一些题中只有1个元素的堆的个数会是一个分类讨论点
* 在组合游戏中的技巧是对称性的考虑，就是说与对面采用一种完全争锋相对的做法，并且保证无论对面如何出招，自己都有可以采用的应对招数